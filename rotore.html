<!-- Copyright: Qianyan Cai -->
<!-- License: GPL v3 -->
<html>
	<meta charset="utf-8" />
	<script src="./format.js"></script>
	<script src="./rotore.js"></script>
	<script>
		if (location.href.endsWith('?')) location.replace(location.href.slice(0, -1))
		function Onload() {
			let url = new URL(location)
			let mode = url.searchParams
			let main = document.querySelector('main')
			let ticky = mode.get('tick') != null
			let tick = document.querySelector('#tick')

			//let { min, max, floor, round, ceil, PI } = Math, PI2 = PI+PI
			let sname = ['I', 'C', 'P', 'E']
			//let scolor = ['#c9c9ff56', '#e3f3e3', '#ffc0c05c', '#e7e6ec']
			//let scolor = ['#b6f6b650', '#e6f3ff', '#ffd0d95c', '#eeecf0']
			//let scolor = ['#a6f0a356', '#dcecff', '#ffc0c05c', '#e7e6ec']
			let scolor = ['#dcf9dc', '#dcecff', '#ffe9e6', '#e7e6ec']
			//let slight = ['#f0fff0', '#f6f9ff', '#fff6f6', '#f6f5f7']
			let sdual = mode.get('.2') != null
			let size = mode.get('size') ?? 360
			let conf = { N: mode.get('n') | 0, size }
			let ticks = []

			if (ticky) {
				for (let N of conf.N >= 2 ? [conf.N] : [2, 3, 4, 5, 6, 7]) {
					for (let P of conf.N >= 2 ? [undefined, 0, 1, 2] : [undefined])
						ticks.push([new Rotor({ ...conf, N, P })])
					tick.max = max(tick.max, 720 + (ticks.at(-1)[0].NS - 4) * 40)
				}
				for (let t of ticks.slice(0, ceil(ticks.length / 2))) t[1] = Canv()
				for (let t of ticks.slice(0, ceil(ticks.length / 2))) Text(DrawSS(t[0], Canv()))
				Break()
				for (let t of ticks.slice(ceil(ticks.length / 2))) t[1] = Canv()
				for (let t of ticks.slice(ceil(ticks.length / 2))) Text(DrawSS(t[0], Canv()))
				Break(), Tick()
			} else if (conf.N >= 2) {
				let rot = new Rotor({ ...conf })
				let ssub = rot.N <= 3 ? 6 : rot.N == 5 ? 5 : 4
				for (let ss = 0; ss < rot.NS; ss++) {
					for (let s = ss; s < ss + 1; s = (round(s * ssub) + 1) / ssub)
						Text(Draw(rot, s, Canv(), true), round((s % 1) * ssub))
					if (ssub >= rot.NS || ss & 1) Break()
				}
			} else {
				for (let N of [2, 3, 5]) {
					let rot = new Rotor({ ...conf, N })
					for (let s of sname.keys()) Text(Draw(rot, s, Canv()))
					Text(DrawSS(rot, Canv()))
					rot = new Rotor({ ...conf, N, P: 0 })
					Text(DrawSS(rot, Canv()))
					Break()
				}
			}

			function Draw(rot, s, canv, p) {
				let $ = rot.$(canv)
				let s0 = s | 0
				//for (let ss = s0; (ss = (ss + sname.length) % rot.NS) != s0; )
				//	$.SS(ss, Scolor(s0, false, slight))
				if (abs(s - round(s)) <= 1 / 15) $.SS(Spair(s), Sstyle(Spair(s)))
				$.SS(s0, Sstyle(s0))
				let T = rot.TS(s)
				$.GG(), $.g(), $.Gg(T), $.G(T)
				if (p) $.PN(T), $.QN(T), $.PBC(T)
				else $.Q(T, 0, 0)
				$.RR(T), $.BB()
				$.param(T)
				return (canv.rot = rot), (canv.T = T), (canv.S = s), canv
			}
			function DrawSS(rot, canv) {
				let $ = rot.$(canv)
				$.GG(), $.g(), $.BB()
				for (let s of sname.keys()) $.RR(rot.TS(rot.N == 2 ? s / 2 : s))
				$.param()
				return (canv.rot = rot), (canv.T = canv.S = null), canv
			}
			function Tick() {
				let s = tick.value | 0
				s = s <= 720 ? s / 180 : 4 + (s - 720) / 40
				for (let t of ticks) {
					t[1].canvas.getContext('2d').clearRect(0, 0, size, size)
					Text(Draw(t[0], s, t[1], true))
				}
			}
			;(tick.disabled = !ticky), (tick.oninput = Tick)
			ticky && tick.focus()

			function Canv() {
				let $ = document.querySelector('template').content.cloneNode(true)
				let canvas = $.querySelector('canvas')
				canvas.width = canvas.height = size
				let text = $.querySelectorAll('pre')
				main.insertBefore($, main.lastElementChild)
				return { canvas, text, param: text[3] }
			}
			function Break() {
				main.insertBefore(document.createElement('br'), main.lastElementChild)
			}
			function Text(canv, ...texts) {
				let $ = canv.text
				let s = floor(canv.S).mod(sname.length)
				let ss = floor(canv.S / sname.length) + 1
				if (canv.S == null) $[0].textContent = `${sname.join('')}${texts[0] ?? ''}`
				else $[0].textContent = `${ss == 1 ? '' : ss}${sname[s]}${texts[0] ?? ''}`
				let t = (canv.T ?? 0) / PI2
				let tn = t * canv.rot.N
				t = _`${floor(t)}{}+${floor(t * 360).mod(360)}{03}\n`
				tn = _`${floor(tn)}{}+${floor(tn * 360).mod(360)}{03}\n`
				$[1].textContent = (canv.T != null ? t + tn : '') + (texts[1] ?? '')
				$[2].textContent = texts[2] ?? ''
				return canv
			}
			function Spair(s) {
				let sp = round(s)
				return sp + (sdual ? sp ^ 1 : sp - 1) - (s | 0)
			}
			function Sstyle(s, color = scolor) {
				return { color: color[floor(s).mod(sname.length)] }
			}

			function Url(url, k, v, bool, replace) {
				if (bool) v ? url.searchParams.set(k, '') : url.searchParams.delete(k)
				else v != null ? url.searchParams.set(k, v) : url.searchParams.delete(k)
				url.searchParams.sort()
				if (replace) history.replaceState(null, '', url), location.reload()
				return url
			}
			document.querySelector('#ticky').checked = ticky
			document.querySelector('#ticky').onchange = function () {
				Url(url, 'tick', !(this.checked = ticky), true, true)
			}
			let vert = mode.get('vert') != null
			document.querySelector('#vert').checked = vert
			document.body.className = vert ? 'vert' : ''
			document.querySelector('#vert').onchange = function () {
				Url(url, 'vert', !(this.checkd = vert), true, true)
			}
			for (let a of document.querySelectorAll('a')) {
				let u = new URL(a.href)
				a.href = (Url(u, 'tick', ticky, true), Url(u, 'vert', vert, true))
			}
		}
	</script>
	<body onload="Onload()">
		<template>
			<figure>
				<canvas></canvas>
				<div>
					<pre></pre>
					<pre></pre>
					<pre></pre>
					<pre></pre>
				</div>
			</figure>
		</template>
		<nav>
			<aside>外旋轮线<br />转子引擎</aside>
			<a href="?">对比</a>
			<a href="?n=2">二角</a>
			<a href="?n=3">三角</a>
			<a href="?n=4">四角</a>
			<a href="?n=5">五角</a>
			<a href="?n=6">六角</a>
			<a href="?n=7">七角</a><br />
			<input id="vert" type="checkbox" /><label for="vert">竖向</label>
			<input id="ticky" type="checkbox" /><label for="ticky">冲程步进</label>
			<input id="tick" type="range" value="0" disabled />
		</nav>
		<main>
			<summary>
				请使用最新版浏览器，支持canvas画图。参数说明：
				<pre>
<!--			--->转子旋转角(绿腰线)
<!--			--->曲轴旋转角(转子节圆远端)

<!--			--->N 转子顶角数
<!--			--->E 偏心距
<!--			--->P 转子顶半径
<!--			--->K 压缩比、膨胀比
<!--			--->V 工作容积(单区最大-最小) | 绿腰线容积(当前-最小)
<!--			--->2倍连杆活塞比 | 余弦比 | 绿腰线比(当前与工作容积比)
<!--			--->总容积(排量、缸体-转子) : 与工作容积比 | 缸体体积
<!--			--->BP 缸体转子间隙 C 最大接触角(缸体法向夹转子顶径向) | 当前接触角
<!--		---></pre>
				版权所有 蔡倩彦 | 开源许可 GPLv3
			</summary>
		</main>
	</body>
	<style>
		body {
			width: max-content;
			margin: 0;
			padding: 0.3rem;
			background-color: #eee;
		}
		main {
			white-space: nowrap;
			font-size: 0;
			width: max-content;
		}
		body.vert main {
			writing-mode: vertical-lr;
		}
		main > * {
			white-space: initial !important;
			writing-mode: initial !important;
			font-size: initial !important;
		}
		figure {
			all: unset;
			display: inline-block;
			position: relative;
			margin: 0.3rem;
		}
		figure canvas {
			background-color: #fff;
		}
		figure div {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 10;
			display: grid;
			grid-template: auto / auto auto;
			place-content: space-between space-between;
		}
		figure pre {
			margin: 0;
			font-size: 14px;
		}
		figure pre:nth-child(2),
		figure pre:nth-child(4) {
			text-align: right;
		}
		summary {
			display: inline-block;
			width: min-content;
			text-align: center;
			padding: 0.5rem;
		}
		summary pre {
			display: inline-block;
			text-align: right;
			margin: 0.7rem 0;
		}
		nav {
			line-height: 1.5rem;
			white-space: nowrap;
		}
		nav * {
			vertical-align: middle;
		}
		aside {
			float: left;
			margin: 0 2rem;
		}
		a {
			text-decoration: none;
			color: #33c;
			margin-right: 1rem;
		}
		nav label {
			margin-right: 1rem;
		}
		#tick {
			width: 50rem;
			outline: none;
		}
	</style>
</html>
